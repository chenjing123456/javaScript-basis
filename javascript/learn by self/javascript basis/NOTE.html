
一.面向对象的学习

#jsday01

1.javascript简介

```
  js的历史：
    javascript是1995年诞生的，当时是为了处理以前由服务器语言负责的没有填写的必填域，是否输入了有效的值的判断。由网景公司开发而成的LIVEScript,后来搭了java的顺风车改成javascript,因为是不共享的，后来不同的浏览器形成了不同的javascript，后期为了开发者的方便就从不同的浏览器中的javascript提出相同的核心的部分称为ECMAScript,作为javascript的实现标准。

    javascript包括ECMAScript(核心js)，BOM和DOM.
    java和javascript几乎没有任何关系。
```

2.特点

  * 脚本语言
        ```
        标记语言:html,没有逻辑能力和行为能力，只能够被读取
        脚本语言：js,本身具有行为能力和逻辑能力，需要被浏览器解析(浏览器内置解析器)执行
        编译语言：java,本身具有行为能力和逻辑能力，需要编译运行
                        需要进行.class编译（javac） 运行（java）
        ```

  * 解释性语言
    ```
    浏览器中内置解析器（用来解析执行代码）
        火狐：js解析器
        谷歌：js解析器
            编译型语言
                Java C
                    .java->.class   字节码
                    .c   ->.o       二进制
                        编译：语法校验
    ```

  * 弱类型语言
        javascript：
            弱类型语言（语言宽松）
                var a=12;//a:number
                    a="hello";//a:string 正确
                    a=true;//a:boolean;
        java:
            强类型语言（语言严格）
                int a=12;
                    a="hello";//代码报错
  * 从上往下顺序解析执行
        html:从上往下

3.javascript的实现
```
一个完整的javascript的实现包括三个部分
    ECMAScript（核心js）
        ECMA-262 定义的EMCAScript与Web浏览器没有依赖关系。浏览器仅是ECMAScript实现可能的宿主环境之一，宿主环境不仅提供基本的ECMAScript实现同时也提供该语言的扩展，以便语言与环境之间对接交互。扩展如DOMECMA规定了这门语言的组成部分
        1，语法
        2，类型
        3，语句
        4，关键字
        5，保留字
        6，操作符
        7，对象（万物皆对象）
    DOM（文档对象模型）
        DOM(Document Object Model) 是针对XML但经过扩展用于HTML的应用程序编程接口。DOM将整个页面映射成一个多节点结构。
                html代码：
                <html>
                    <head>
                        <title>hello</title>
                        <meta>
                    </head>
                    <body>
                        <p>nihao </p>
                        <!--注释节点-->
                    </body>
                </html>
                    dom模型
                    doucment
                        |
                    html节点
                    /   \
                head    body
                 |       |
                title    p
                 |       |
                'hello' '你好'
    BOM（浏览器对象模型）
        alert()也属于
        
        BOM(Browser Object Model),开发人员可以使用BOM控制浏览器显示的页面以外的部分。弹出新浏览器窗口；移动，缩放，关闭浏览器的功能；提供浏览器详细信息的navigator对象;提供浏览器所加载页面的详细信息的location对象；提供用户显示器分辨率详细信息的screen对象；对cookies的支持；支持XMLHttpRequest,IE中的ActiveXObject自定义对象

        BOM和DOM之间的关系，由于BOM的核心对象是window，window对象有一个document属性，而document是DOM的根节点，所以BOM可以操作DOM.


```

4.兼容性

  * JavaScript的三个组成部分，在当前五个主要浏览器（IE,Firefox,Chrom,Safari,Opera）中得到了不同程度支持，其中，所有浏览器对ECMAScript3支持大体都还不错，对ECMAScript支持程度越来越高，但对DOM的支持彼此相差较多，对已经正式纳入HTML5标准的BOM来说，尽管各浏览器都实现了某些总所周知的共同特性，但其他特性还因浏览器而异。

5.script标签的属性
```
  * type: 可看做是language的替代属性(language已废弃)，表示编写代码使用的脚本语言的内容类型，MIME这个属性非必须，默认是text/javascript
  * src: 表示包含要执行代码的外部文件（与用link标签引入的css样式表中的href相区别）

  * async：立刻下载脚本，但应妨碍页面中其他操作（只针对外部脚本文件）
  * charset:指定src属性指定的代码的字符集，大多数浏览器会忽略这个值。
  * defer: 表示脚本可以延迟到文档全部被解析和显示之后再执行（只针对外部脚本文件）
```

6.在HTML中使用JavaScript
```
    1.直接嵌入在页面中
       将js代码嵌入在head标签(body标签，或者body之后html之后的标签)内部
            <script type="text/javascript">/*js代码*/</script>
       将js代码嵌入在html标签内部
            <a href="javascript:void(0)"></a>
            <div onclick="alert("hello");"></div>
    3.引入外部的js文件
        不能再已经引入外部文件的script标签内部书写js代码，否则会被浏览器忽略执行
            <script type="text/javascript" src="js/1.js"></script>
```

7.注意事项
```
1.不要在<script>标签中再填写其他js代码，否则将会忽略(引入外部的js文件方式)

2.src 可以跨域访问 。例如：http://cdn.code.baidu.com/ 百度静态资源公共库(后期的ajax跨域访问)

3.script标签位置<head>标签中：等到全部的js代码都被下载,解释和执行完成后才能开始呈现页面的内容。可将代码引用放到<body>元素放到内容后面。

4.延迟脚本:(defer="defer"),延迟至浏览器遇到</html>标签后再执行。

5.<noscript >当浏览器不支持脚本或者浏览器支持脚本，脚本被禁用，可以让页面平稳的退化.
</noscript>
    <noscript>
        本页面需要浏览器支持（启用）javascript
    </noscript>
```

6.基础语法
```
    1) 区分大小写 
        typeof 关键字， typeOf 非关键字
    2) 标识符
      指变量，函数，属性的名字或者函数的参数。标识符是按照以下规则组合起来的一或多个字符：
      1.字母，数字，下划线，$组成。
      2.只能以字母，下划线，$开头。
      3.不能将关键字作为标识符。
      4.命名尽量采用驼峰式命名
    3) 注释
        //单行注释
        /*
        多行注释
        */
    4) 语句
        每个语句以分号结尾，如果省略分号，由解析器确定语句的结尾，即分号可以省略，但是我们要求每个语句的末尾都应该有分号
```

7，关键字保留字 
```
    1) 关键字:(在js中有特殊功能)
        break       do      instanceof  typeof
        case        else    new,        var
        catch       finally return,     void
        continue    for     switch,     while
        debugger    this    function    with
        default     if      throw       delete
        in          try

    2) 保留字：(将来可能成为关键字)
        abstract    enum    int         short
        boolean     export  interface   static
        byte        extends long        super
        char        final   native      synchronized
        class       float   package     throws
        const       goto    private     transient
        debugger    double  implements  protected
        volatile    import  public
```

6.script标签的defer和async属性（异步加载：无阻塞并发处理）：建议使用defer，但是它只对外部js有效。

  * 正常情况下，当浏览器在解析HTML源文件时如果遇到外部script,那么解析过程会暂停，并发送请求来下载script，只有script完全下载并执行后才会继续执行DOM解析。但是通过script的async或者defer属性来让脚本不必同步（一步一步按步骤）执行。
  
  * async和defer都不会暂停HTML解析就立刻被下载，两者都支持onload事件回调来解决需要该脚本来执行的初始化。两者都只能用在外部JS文件中。
  
  * 两者的区别在于执行时的不同：
  ```
    async h5新增属性，用于异步下载脚本文件，下载完成后立即解析执行代码。
    脚本在script文件下载完成后立即执行，并且执行时间一定在window的load事件触发之前，但不确定与DOMContentLoaded事件的执行顺序，这意味着多个script脚本很可能不会按照其在页面出现的顺序执行。
    load事件一般是在HTML中指定的资源都加载完成之后触发的，比如图片什么的。

    defer 开启新线程下载脚本文件，并使脚本在文档解析完成后执行。
    脚本执行时间为DOM解析完成之后，document的DOMContentLoaded事件和load事件触发之前。浏览器确保多个defer脚本按其在HTML页面出现顺序来依次执行。
    DOMContentLoaded事件是在DOM加载完，也就是HTML和JS解析完成之后就触发的。
  ```

7.页面的加载和渲染过程
    
  * 浏览器通过HTTP协议请求服务器，（浏览器）获取HTML文档并开始从上到下解析（浏览器解析器），构建DOM.
  * 在构建DOM过程中，如果遇到外联样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件。
  * 样式文件下载完成之后，构建CSSDOM，脚本文件下载完成之后，解释并执行。然后继续解析文档DOM
  * 完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口
  
  * 在这一整个过程中，脚本文件的下载和执行是与文档解析同步执行的，也就是说会阻塞文档的解析，如果控制的不好，在用户体验上就会造成不同程度的影响。

![](day01/defer和async.png =50*50)



#jsday02


1.创建变量

  * 变量声明
        var str;
  * 变量初始化
        赋值操作
        str ="arrsy";

  * 变量的更改
        str =2;
        str =true;
  * 变量的使用
        console.log(str);//true
        打印在控制台上
        str = str+"hello";//truehello
  * 变量的声明和初始化
    var arr1 =[1,2,3];
    var arr2 =[3,4,2];
    var arr =[arr1,arr2];
  * 声明多个变量
    var str1 ="hello",str2 ="ls",str3="ld";

    1.var age =12;
    2.age =12;

2.全局变量和局部变量

    全局变量声明的两种方式：
        用var声明在script标签内部的
        不用var声明在script标签内的任意位置处
             若没有用var声明在函数体内部的变量只有在函数被调用并且执行到变量声明处才有这个全局变量，并且能被使用。
                function test(){
                    message = "hello";  
                }
                test();
                alert(message); //可以访问 没有用var 声明的变量属于全局变量，当函数被调用之后页面就有了这个全局变量

    局部变量：用var 声明在块中（方法体中）
            function test(){
        var message = "hello";  
          }
          test();
          alert(message); //错误 局部变量只能在局部作用域内访问

3.数据类型
    1)分类
        ECMAScript不支持自定义类型，只有6种数据类型：
      5中基本数据类型（简单数据类型）
          Undefined 未定义 "undefined"
        var a ;
        var a = "undefined";//不做
          Null    空引用数据类型 "null"
        var a = null;
          Boolean   布尔类型 true/false
        var a = false;
          Number    数字类型
        整数(八进制 十进制 十六进制)
        浮点数(小数)
          String    字符串类型 "" ''
        "hello" 'hello'
        var a ="undefined";
        var a ='hello';
            
      1种引用数据类型（复杂数据类型）
          Object(本质由一组无序的键值对组成)
      1.
      var teacher=new Obejct();
      typeof(student)//object
        teacher.age=12;
        teacher.gender="男";
      console.log(teacher.age);//12
        2.
      var student={
        name:"zhangsan",
        age:12
      };//空对象
    
    2)typeof操作符(该方法本身会返回一个字符串类型)
      返回该变量名所指向数据的类型
      语法：
      typeof 变量名  console.log(typeof(a));

      可有取值如下
          "undefined"   未定义
          "boolean"   布尔类型
          "string"    字符串
          "number"    数值
          "object"    对象或者null
          "function"    函数
    3)instanceof操作符 返回布尔值，用来判断是否是某个具体的引用数据类型
        var stu =new Object();
    console.log(stu instanceof Object);//true

    function eat(){

    }
    console.log(eat instanceof Function);//true

4.基本数据类型

    1）undefined
        值是undefined的几种情况（类型也是undefined）
            1.变量声明但未赋值
            /*
            var a;
            console.log(a);//undefined
            console.log(typeof(a));//undefined
            */
            //typeof()方法返回字符串类型

            2.将变量值显式设置为undefined
            /*var a=undefined;
            console.log(a);
            console.log(typeof(a));*/

            3.一个未声明的变量
            // console.log(a);//报错 试图获取一个未声明的变量

            console.log(typeof(a));//不报错 没有声明的变量的类型是undefined

            4.访问变量没有的属性时
            5.函数没有返回值的时候
    2）null:空引用数据类型，即将要指向一个引用数据类型
        
        值为null,类型为Object类型
        var a =null;
        console.log(a);//null
        console.log(typeof(a));//Object

        undefined是派生自Null的，
        console.log(null==undefined);//true 相等不全等
        console.log(null===undefined);//false
            【使用情景】
        如果一个变量准备将来保存对象，可以将该变量初始化null而不是其他，这样可以通过检查null值就可以知道相应的变量是否已经保存了一个对象的引用。
          if(car !=null ){
            //car对象执行某些操作
          }
            实际上 undefined 派生自null值。undefined == null 结果为 true
            null与undefined用途不同，null可以用来表示一个空对象，但是没有必要把一个变量的值显式设置为undefined
    
    3)boolean 布尔类型
        该类型只有两个值，true,false虽然boolean类型的取值只有两个，但是ECMAScript中所有的类型的值都有与这两个Boolean值等价的值
        除了null undefined 0 "" NaN false 是false，其余都可以转换为true
            var c =true;
            var b =false;
            console.log(c);//true
            console.log(typeof c);//boolean
            var d =Boolean(a);//null转换为布尔值为false
            var e =Boolean(b);
            console.log(d);//false
            console.log(typeof d);//boolean
            console.log(e);//false
            console.log(typeof e);//boolean
    
    4)number数值类型
        分为整型和浮点型
     1) 表示方法：
      1. 整数：
        
            十进制数： 55  0~9
            八进制数： 首位为0,其他位为（0~7 如果字面值超出了范围，前导0将会被忽略）
          070 （表示 7*8一次方 =  56）
          079 （超过了范围，表示79）
            十六进制： 前两位为0x，其他位为(0~9，A~F)
      2. 浮点数
        所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后必须至少有一位数字。浮点数值的最高精度是17位小数。
          例如： var f = 1.2;
          科学计数法：e
              var e = 3.125e7;    //31250000

     2) 数值范围
      由于内存的限制，ECMAScript不能保存世界上所有的数值。ECMAScript能表示的最小数值保存在Number.MIN_VALUE中，能表示的最大的数值保存在Number.MAX_VALUE中。如果某次计算的结果超过了JavaScript数值范围，将会返回Infinity(正无极)或者-Infinity(负无极)
            
            使用 isFinite()函数可以判断参数是否在最大值和最小值之间，如果在，返回true

      在绝大数浏览器中：
        Number.MIN_VALUE ： 5e-324
            Number.MAX_VALUE ：  1.7976931348623157e+308
      如果某次计算返回了正的或者负的Infinity,那么该值无法继续参与下一次计算。可以使用isFinite(para)函数判断para 是否在最大数最小数之间
     3) 非数值 NaN (not a number)
          该数值表示一个本来要返回数值的操作数未返回数据的情况。
        var a = 10/'a';
        console.log(a);   //NaN
        
      任何涉及到NaN的操作都会返回NaN; NaN与任何值都不相等，包括NaN本身。
      
            isNaN，判断参数是否“不是数值”或者不能转为为数值时，当参数para不是数值的时候返回true 
        isNaN(NaN);   true
        isNaN("blue");  true  无法转换为数值
        isNaN(10);    false 10
        isNaN("10");  false 10
        isNaN(true);  false
  注意：
      1) 默认情况下，ECMAScript会将小数点后带有6个零以上的浮点数转化为科学计数法。
      0.0000003 => 3e-7(3*Math.pow(10,-7))  e=10
      2) 在进行算术计算时，所有以八进制十六进制表示的数值都会被转换成十进制数值。
          
      3) 保存浮点数需要的内存是整数的两倍，因此ECMAScript会不失时机将浮点转换为整数(比如浮点数只有0的时候)
          例如：
          var a = 1.;
          var b = 1.0;  都将解析为1
      4) 避免测试某个特点的浮点数值，是使用IEEE 754数值的浮点计算的通病
        例如： 0.1+0.2结果不是0.3，而是0.30000000000000004

        Math.pow(2, 53)，十进制即 9007199254740992
              eg:
            // var p =0.1;
            // var o =0.2;
            // var result =p+o;
            // console.log(result);//失去精度 因为计算机解析的时候是32位的二进制数0和1  0.300000000004

            //失去精度的解决方法，把两个数变成整数，整数不会失去精度
            var p =0.1*10;
            var o =0.2*10;
            var result =(p+o)/10;
            console.log(result);
      
    5）String
      字符串类型 "" ''
      该类型表示由零个或者多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号或者单引号表示
      1)字符字面量
          \n  换行
          \t  制表
          \b  退格
          \r  回车
          \\  斜杠
          (\' \')  (单引号)
          (\" \")  (双引号)
      2)字符长度  
        通过length属性获取字符长度
      
5.Object
  ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行"new 对象类型"来创建。
        var o = new Object();
  Object类型是所有它的实例的基础，换句话说，Object类型所具有的任何属性和方法，同样存在于更具体的对象。
    
          constructor:构造器，表示对象实例的构造函数。保存用户创建当前对象的函数
          
          hasOwnProperty(propertyName); 用于检查给定的属性是否在当前对象实例中(属性为自己的则为true,如果是继承的则为false)
          
          isPrototypeOf(object);      用于检查传入的对象是否是原型
          
          propertyIsEnumerable(propertyName); 用于检查给定的属性在当前对象实例中是否存在
          
          toLocaleString();       返回对象的字符串表示，该字符串与执行环境的地区对应
          
          toString();   返回对象的字符串表示
          valueOf();          返回对象的字符串，数值，布尔值的表示。

  ``` 
      var person={
        name:"zhangsan",
        age:21
      }
      console.log(person.hasOwnProperty("gender"));//false
      console.log(person.constructor)//object
      console.log(Object.prototype.isPrototypeOf(person)+"looj"); 
      console.log(person.propertyIsEnumerable("name"))//true

      var d = new Date()
      console.log(d.toLocaleString())//2017/8/16 下午11:24:59 

      var date = new Date(2013, 7, 18, 23, 11, 59, 230);
      document.write( date.toString() ); // Sun Aug 18 2013 23:11:59 GMT+0800 (中国标准时间)

      var eles = document.getElementsByTagName("body");
      document.write( eles.toString() ); // [object NodeList]
      document.write( eles[0].toString() ); // [object HTMLBodyElement]

      var array = ["CodePlayer", true, 12, -5];
      document.write( array.toString() ); // CodePlayer,true,12,-5
  ```

    对于不同类型的对象，js定义了多个版本的 toString 和 valueOf 方法
      
      toString:
      （1）普通对象，返回 "[object Object]";
      （2）数组，返回数组元素之间添加逗号合并成的字符串;（逗号也算这个字符串的长度）
      （3）函数，返回函数的定义式的字符串;
      （4）日期对象，返回一个可读的日期和时间字符串;（返回时期字符串）
      （5）正则，返回其字面量表达式构成的字符串;
       (6) HTML节点：返回 [object HTMLBodyElement]
      
      valueOf:
      （1）日期对象，返回自1970年1月1日到现在的毫秒数;（返回数值）
      （2）其它均返回对象本身;


#jsday03

1. 类型转换（其他数据类型转换为基本数据类型的boolean string number）
  &强制转换（显式转换）
    01) 其他数据类型到Boolean类型转换
        通过Boolean() 函数转换
        除了0 null undefined "" NaN转换为false之外。其余的都转换为true.

           【Boolean   true      false】
            String      非空字符串   ""
            Number      任何非0        0和NaN
            Object      任何对象    null
            Undefined   n/a         undefined   (n/a not applicable 不适用)
        例如：
            Boolean("");        //false
            Boolean(0);         //false
            Boolean(NaN);       //false
            Boolean(null)       //false
            Boolean(undefined)  //false
            Boolean("briup");   //true
            Boolean(1);         //true

    02) 其他数据类型到数值类型转换
        1.Number()

            1) 如果转换的值是null,undefined,boolean,number
        *       Number(undefined);  //NaN
                Number(true);       //1
                Number(false);      //0
                Number(null);       //0
                Number(10);         //10 如果是数字值,原样输出
        
            2) 如果是字符串：
                Number("");     //空字符串被转换为0

                Number("123");  //如果仅包含数值，转换为对应的数值
                Number("234.1");//解析为对应的小数
                Number("+12.1");// 12.1 首位为符号位，其余为为数值，转换为对应的数值
                Number("-12.1"); //-12.1

        *       Number("1+2.3");//NaN 符号位出现在非首位位置，解析为NaN
        *       Number("123ac");//包含其他字符： NaN
        *       Number("123/");//包含其他字符： NaN

                Number("0xa");  //如果仅包含十六进制格式，转为为对应的十进制的值
                Number("010");  //【注意！】不会当做八进制被解析，结果为10
                
                Number(" 12");  //12
        *       Number("1 2");  //NaN 非首位出现特殊字符(符号位和空格)转换为NaN
        ****总结：1.转换为NaN的三种情况
                        undefined
                        当字符串里 符号位和空格出现在非首位的位置
                        当字符串 包含其他字符时（包括英文字符和特殊字符/$&*等）
                  2.其余的字符串类型都可以转换为数值，并且不解析字符串形式的八进制，忽略前导0直接进行输出；但是解析字符串的十六进制，会进行转换然后输出
                  3.符号位出现在首位的位置的字符串类型，是可以变成正数和负数的数值

        2.parseInt()
            1) 如果转换的值是null,undefined,boolean,number
            *   parseInt(true);     //NaN
            *   parseInt(false);    //NaN
            *   parseInt(null);     //NaN
            *   parseInt(undefined);//NaN
                parseInt(10);       //10 如果是整数值，原样输出
                parseInt(10.3);     //10 如果是小数，舍去小数点一级后面的内容
                parseInt(0);    //0
            2) 如果是字符串：
            *   parseInt("");     //NaN；空字符串被转换为NaN
                parseInt("123");  //123；如果仅包含数值，转换为对应的数值
                parseInt("234.1");//234；小数点后面的数值省略
                parseInt("+12.1");//12； 首位为符号位，其余为为数值，转换为整数
                parseInt("0xa");  //10； 如果仅包含十六进制格式，转为为对应的十进制的值
                parseInt("010");  //10； 【注意！】不会当做八进制被解析，结果为10
                parseInt("1+2.3");//1;  如果首位为数值，依次向后解析，找到连续的数值，直到遇到第一个非数值的，将之前获取的数值转换为Number返回
                parseInt("123ac");//123;

            3)进制的转换
              var a = parseInt(3, 8)//八进制是0-7
              var b = parseInt(3, 2)//二进制只有0 1两个数组成 0-1
              var c = parseInt(3, 0)//十进制 0-9
              console.log(a);//3
              console.log(b);//NaN
              console.log(c);//3

              parseInt("10");     //返回 10
              parseInt("19",10);    //返回 19 (10+9)
              parseInt("11",2);   //返回 3 (2+1)
              parseInt("17",8);   //返回 15 (8+7)
              parseInt("1f",16);    //返回 31 (16+15)
              parseInt("010");    //当做十进制进行解析
              parseInt("0xa");    //当做十进制进行解析

            parseInt(string, radix)
              string  必需。要被解析的字符串。
              radix   可选。表示要解析的数字的基数,即所保存数字的进制的值。该值介于 2 ~ 36 之间。
              如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。
              如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。

            ****总结：1.转换为NaN的几种情况：
                            ""   null undefined NaN boolean 以及 不包含数字的任意字符串
                     2.其他包含数字类型的字符串遵循 从前到后解析直到遇到特殊字符的时候就结束解析 并输出当前位置之前所解析的数值
                     3.剩下的字符串类型都可以转换为数值，并且不解析字符串形式的八进制，忽略前导0直接进行输出；但是解析字符串的十六进制，会进行转换然后输出
                     4.符号位出现在首位的位置的字符串，是可以变成正数和负数的数值
        
        3.parseFloat()
            与parseInt() 类似，特点基本上一致，但是有下面两点不同： 
                1.字符串中的第一个小数点是有效的，而第二个小数点则无效其后的内容会被省略
                2.始终忽略前导0（字符串为八进制和十六进制的都不会进行解析，直接输出）
                    parseFloat("22.3.4")    //22.3
                    parseFloat("022.34");   //22.34
    
    03) 其他数据类型(这里不包括Object类型)到字符串类型转换
        1. toString()函数
        
        ***toString()函数是Object的一个方法，不能被基本数据类型调用，所以当基本数据类型来调用toString()方法来进行字符串数据转换时，
        浏览器会帮我们进行自动装箱和自动拆箱操作，使我们的基本数据类型能够调用toString()方法
        自动装箱：是把我们要调用toString()方法的基本数据类型的变量 封装成函数对象，使他能调用Object的toString()
        自动拆箱：是在进行装箱操作实现调用之后再进行拆箱 即把它从对象转换为原来声明在js中的变量值的默认类型


            1.默认情况下，toString()是以十进制格式返回数值的字符串表示，通过传递参数，可以输入以二进制，八进制，十六进制乃至任意有效进制格式的字符串值
                
                var num = 10;       数值类型
                num.toString();              "10"
                      自动装箱成Number(num)
               随后进行自动拆箱Number(num)--> num   
                
                num.toString(2);    "1010" 先把num转换为二进制再调用toString()方法
                num.toString(8);    "12"   八进制输出
                num.toString(16);   "a"   十六进制输出

            2.所以number和boolean以及string是可以调用toString()方法
            3.但是null ,undefined 没有toString() 方法
                null.toString()         //报错 TypeError: null has no properties   
                undefined.toString();   //报错 TypeError: undefined has no properties

        2. String() 构造函数
            不管你是什么数据类型的值都会转换成值为本身的一个字符串

                String(null)         "null"
                String(true)         "true"
                String(12)              "12"
                String(undefined);   "undefined"

  &自动转换（隐式转换）
    01)其他数据类型隐式转换为number
        一元运算符加+     a=+a;
        一元运算符减-     a=-a;(如果是数值，直接为负号；如果不是，通过Number()转换为数值再变成负号)
        算术运算符+       当m,n两个数不为String,Object类型的时候，先将m,n转换为Number类型，然后再进行计算
        算术运算符-       返回值为【数值类型】。无论操作数为任何类型，先将其使用Number()转换器转换为Number类型，然后再计算。
        算术运算符*      如果有一个操作数不是数值，则先调用Number()将其转换为数值
        算术运算符/      如果有一个操作数不是数值，则先调用Number()将其转换为数值
        算术运算符%      如果有一个操作数不是数值，则先调用Number()将其转换为数值
    02)其他数据类型隐式转换为string
        +""
        加空字符串 3+" "="3";
    03)其他数据类型隐式转换为boolean
        !!a;
            转换为布尔 !!2=true;


2.操作符
    01) 一元操作符
        ++,--,+,-操作符应用任何类型数值都返回一个【数值类型】，先将任意类型的值转换为Number然后进行运算(通过Number()方法进行转换)
        1.递增 ++  
            var a = "11";
            1+a++;
            1+ ++a;
            前置：先进行递增或者递减操作，在进行运算
            后置：先进行运算 再进行递增或者递减操作
        
            对任意数据类型的操作数都适用，使用前先将其转换为数字(Number())，然后再进行运算,在应用于对象的时候，优先先调用对象的valueOf方法，以取得一个可供操作的值,如果子类对象仅重写了toString(),调用该方法。
        
        2.递减 --
            前置：先进行递增或者递减操作 再进行运算
            后置：先进行运算 再递增或者递减操作
            对任意数据类型的操作数都适用，使用前先将其转换为数字，然后再进行运算在应用于对象的时候，先调用对象的valueOf方法，以取得一个可供操作的值,如果子类对象仅重写了toString(),调用该方法。
        
        3.一元加 +
            相当于调用Number();
            var a = "12"
            +a ;    // 12  相当于调用了Number("12")
        4.一元减 -
            将一元减应用于数值时，数值会变成负数。
            将一元减应用于非数值时，遵循与一元加操作符相同的规则，最后将得到的数值转化为负数

    02) 布尔操作符, 非(NOT)
        逻辑非 !
        该操作符应用任何类型数值都返回一个【布尔值】。先将任意类型的数值转换为Boolean，然后取反，
            !a ==> !Boolean(a)

            ！null  ?
            !0      //true
            !""     //true  
            !NaN    //true  
            !false  //true

            连用两次逻辑非 ，就可以将任意数据类型转化为Boolean类型，!!a ==> Boolean(a)
            !!""    //false 隐式转换
    
    03) 逻辑与 && (同真才真，有假则假) 也被称为短路运算符
        可应用于任意数值。如果有一个操作数不是布尔类型，逻辑与就不一定返回boolean类型

        如果第一个是false,则返回第一个数
        如果第一个是true,则返回第二个数

            var s1 = 8;
            var s2 = "briup";
            var s3 = "";
            var result  = s1 && s2; //briup
            var result2 = s3 && s2; //空字符串

    04) 逻辑或 ||(有真则真，同假才假)
        如果第一个为true,则返回第一个数，
        如果第一个为false,则返回第二个数。
    
    05) 加性操作符
        1. 加法 +
            m + n
            1) 当m,n不为String,Object类型的时候，先将m,n转换为Number类型，然后再进行计算
                true + false;     //1；Number(true)+Number(false);
                true + 1;     //2；Number(true) + 1
                null + undefined; //NaN；Number(undefined) -> NaN
            2) 当m,n有一个为String,无论另一个操作数为何（但不为对象）都要转换为String，然后再进行拼接
                "1" + true; // 1true
                "1" + undefined;// 1undefined
                "1" + 1;    // 11
            3) 当m,n 有一个为对象，如果该对象既重写toString,又重写了valueOf方法，先调用valueOf方法获取返回值，将该返回值和另外一个操作数进行运算。如果该对象没有重写valueOf方法，将调用toString方法获取返回值，将该返回值和另外一个操作数进行运算。
                var o = {
                    name:"briup",
                    valueOf:function(){
                        return "1";
                    }
                }
                o+1;        //11 直接参与运算，根据前面两条规则来进行类型转换等，与减法的有对象类型的运算进行对比
        
        2. 减法 -
            返回值为【数值类型】。无论操作数为任何类型，先将其使用Number()转换器转换为Number类型，然后再计算。
            true - 1;       //0;    1-1
            null - true;    //-1 ;  0-1
            1 - undefined   //NaN
            var o = {
                name:"briup",
                valueOf:function(){
                    return “1”;
                }
            }
            o-1;        //0;    o调用valueOf方法，返回了一个字符串类型  然后把它进行数值类型转换（根据原则是Number()，而不是前面加法的方式）  最后和1进行运算
        
        总结：加性操作符在运算时 遇到其中有一个为引用数据类型的时候会默认调用Object的toString()方法，
            当对象中重写了toString()方法时，则调用对象的toString()方法，当对象中重写了valueOf()方法，则调用valueOf()方法。
            如果对象既重写了toString()方法，又重写了valueOf()方法，则调用valueOf()方法。

            注意 toString()和valueOf()方法两者写在对象里重写的话 都是以返回值的类型为基准

    06) 乘性操作符
        返回值为【数值类型】当操作数为非数值的时候执行自动的类型转化Number()

        1. 乘法 *
            如果两个数都是数值，执行常规的乘法计算
            如果一个操作数是NaN,结果为NaN（0*NaN=NaN）
            超过数值范围返回Infinity
            如果有一个操作数不是数值，则先调用Number()将其转换为数值。
        2. 除法 /
            如果一个操作数是NaN,结果为NaN （0/0 ; NaN）
            一个非0值除0 Infinity   
            如果有一个操作数不是数值，则先调用Number()将其转换为数值。
            var s1 = 5;
            var s2 = 2;
            var result = s1/s2;  //2.5
        3. 取余 %
            如果两个数都是数值，执行常规的取余计算
            如果一个操作数是NaN,结果为NaN（任意数%0 ; NaN）
            如果有一个操作数不是数值，则先调用Number()将其转换为数值

    07) 关系操作符
        < > <= >= ,返回一个【Boolean】值
        1.如果两个操作数是字符串，比较字符串中对应位置的每个字符的字符编码值
            "a">"b" //false
            "1">"a" //false
        2.如果一个操作数是数值，将另外一个操作数也转换为数值Number()进行比较
            "3">1;          //true
            3>true;         //true 3>Number(true)
            3>undefined;    //false Number(undefined)=NaN ;任何数和NaN比较结果都为false
        3.如果一个操作数是对象，默认调用toString(),如果对象重写了toString()方法，则调用valueOf；如果对象重写了valueOf()方法 则调用valueOf()方法；如果两个都重写了，则调用valueOf();

            var o = {
                name:"briup",
                valueOf:function(){
                    return "13";
                }
            }
            o>2     // true ; "13">2
    08) 相等操作符,返回【Boolean】（比较内容）
        1.相等和不相等 ==, != (先转换在比较)
            1.如果两个操作数都为字符串，比较字符序列
            2.如果两个操作数都为数值类型，比较值的是否相等
            3.如果一个操作数为number类型，另外一个操作数为undefined,null,boolean,string之一，先将这些数据类型转换为数值，再进行比较
                var a=3;
                var b="4";
                a==b//false
            4.如果两个操作数都是对象，比较是的对象的引用地址
            5.null == undefined         //true    undefined 派生自null
            6.NaN与任何值（包括NaN）相等比较结果为false，不等结果为true.
            

        2.全等和不全等(比较类型和内容)
            仅比较不转换，先比较两个数所属的数据类型，如果类型不同则不同，如果类型相同，再继续比较两个数的值
            console.log("55" == 55); true
            console.log("55" === 55);false
        
        null与undefined是相等不全等的：
            null == undifined;      //true null派生自undifined
            null === undifined;     //false

    09) 三目运算符 ? : 
        variable = boolean_expression ? true_value : false_value;
        如果boolean_expression为true,将true_value赋给variable，否则将false_value赋给variable
        
        例如：求任意两个数之间最大值
           function max(m,n){
                return m>n?m:n; //如果m>n为true返回m,如果m>n为false,返回n
           }
    10) 赋值运算符 = 
       将右侧的值赋给左侧的变量
       可以和其他算术运算符连用 *= %= += -= 等
       var a = 4;

       a *= 3; //=> a = a*3;
    11) 逗号操作符
       可以在一条语句中执行多个操作
       var num1=1,num2 = 2, num3 = 3;


#day04

1.流程控制语句(先填框架再写代码)
    01) if语句
        if(condition){
            statement1;
        }else{
            statement2;
        }
        condition表示任意表达式，该表达式求值的结果不一定是布尔类型，如果不是布尔类型，ECMAScript会调用Boolean() 转换函数将这个表达式结果转换为一个布尔类型，如果condition求值结果为true,执行statement1。如果求值结果为false，执行statement2

        if(condition){
            statement1;
        }
        statement2;(此语句必然会执行)

        
    02)switch语句
        switch(expression){
            case val:

                break;
            case val2:

                break;
            default:
        }
        ==>
        switch(expression){
            case val:{

                break;
            }
            case val2:{
                break;
            }
            default:
        }
      可以在switch语句中使用任何数据类型。
      case的值不一定是常量，也可以是变量，甚至是表达式。

      expression === val（两者比较的是全等）
      default:语句放在最后可以不加break;但是不放在最后需要加break;

      break 跳出循环执行下一条语句
      continue 跳出当前循环 执行下一次循环


2. 循环语句 
    01)for语句
        for循环是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是for循环的语法：
        初始化表达式，控制表达式，循环后表达式
        for(initialization;expression;post-loop-expression){
            //loop option
        }
        三要素：
            初始条件
            结束条件(循环执行条件)
            迭代条件
        for(var i=9;i<=5;i++){
            //循环体
            console.log();
        }


        例如:
        var sum = 0;
        for(var i=0;i<10;i++){
            sum +=i;
        }
        console.log(i); //10  

        ECMAScript不存在块级作用域，在循环内部定义的变量i也可以在外部访问到
    
        死循环
            1)for(;;){
                //当for中的表达式省略的时候，会创建一个死循环
            }
            2)while(true){
            
            }

    02) do-while语句 
        var i=1; 
        do{
            
        }while(condition); 
        后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。循环体内的代码最少被执行一次。

    03) while语句
        开始条件
        结束条件
        迭代条件

        var i=1;    
        while(结束条件){
            迭代条件
        }
        前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。
        while(false){
            //不会执行代码
        }

    04) for-in 语句（for循环增强）
        是一种精准的迭代语句，可以用来枚举对象的属性
        for(property in expression){
            statement;
        }
        例如:
        打印出window对象中所有的属性
            for(var propName in window){
                console.log(propName);
            }


#day05
  
1.对象
  (一)创建对象的方式：
      1)对象字面量
          var obj={
              name:"ls",
              "first-name":"zs",//当属性名包括特殊字符时必须用引号
              age:12,
              valueOf:function(){
                  return 1;
              }
          }
      2)用Object()构函创建对象
          var obj=new Object();
          obj.name="zs";
          obj.age=12;
          delete obj.age;
          console.log(obj);
      3)自定义的构造函数创建对象
  
  (二)访问属性
      1).语法
        obj.name;
      2)[]语法 方括号内部必须是一个字符串，也可以是一个类型是字符串的变量
        obj["name"];
      3)把属性存放在变量内部，再通过方括号访问
		var name="name";
		obj[name];

  (三)删除属性：delete关键字
      delete obj.name;
      只能删除对象的自有属性，不能删除继承属性
      销毁对象时，遍历对象的属性，依次删除属性，防止内存泄漏

  (四)检测属性：
      判断属性是否属于一个对象
        1)in:判断属性是否是一个对象的自有属性或者继承属性
            console.log("name" in obj);//true
            console.log("constructor" in obj);//true
        2)hasOwnProperty():判断属性是否是一个对象的自有属性
            console.log(obj.hasOwnProperty("name"));//true
            console.log(obj.hasOwnProperty("constructor"));//false
        3)propertyIsEnumerable():检测给定属性是否是对象的自有属性，并且属性是可枚举的；
            console.log(obj.propertyIsEnumerable("toString"));//false

#day06

对象:键值对（属性和方法）的无序集合
1.对象创建

2.遍历对象for-in
    函数中的属性名不会当做变量被解析。只会是字符串常量
    obj={
        name:"ls",
        age:12
    };
    for(var key in obj1){
        console.log(key,obj1[key]); //用逗号分隔，打印的是字符串 以及 相应的属性值的类型  []能解析变量
        // console.log(key+" "+obj1[key]);用+进行字符串拼接 结果是字符串之间的拼接
     }
    key是字符串类型的变量,代表的是每次遍历从obj中获取的属性名

3.对象的访问
    obj.name;
    obj["name"]/obj["first-name"]; []能解析变量，有特殊字符时使用
    var name="name"; obj[name];

4.删除对象的属性 只能删除对象的自有属性，不能删除继承属性

5.属性检测
    1)in关键字：检测是否是对象的自有属性或者继承属性，是为true;
        console.log("name" in obj);
    
    2)hasOwnProperty()方法：检测是否是对象的自有属性，是为true
        console.log("constructor" in obj);//false
    
    3)propertyIsEnumerable()方法：检测是否是对象的自有属性，并且是否可枚举
        console.log("name:",obj.propertyIsEnumerable("name"));
        一般自有属性都是可枚举的，继承的不可枚举，但是也可以更改属性的枚举特性

6.对象序列化(JSON):轻量型的数据传输的格式
     1)所有的属性都必须用引号引起来的，
          方便前端中内存的数据传递给后台（前后台之间的交流方式）
     2)将对象转换为字符串 JSON.stringify()
        var json =JSON.stringify(obj);//字符串 {"name":"sds","age":13}
     3)字符串转换成对象 JSON.parse()
        var json2='{"name":"sds","age":13}';
        var obj2=JSON.parse(json2);

7.对象的高级特性
    1)Object.defineProperty(对象，对象的属性，对象属性的一些相关特性);
    用来设置对象某个属性的特性值
      
        Object.defineProperty(obj,"weight",{
            value:"80kg", //这个属性的值
            enumerable:false,//是否可枚举，不能被遍历出来
            writable:false //是否可写或可修改
            configurable:是否可两次定义配置等
        })
    2)Object.defineProperties(对象，要设置的属性集合);
    用来设置对象某些属性的特性值
        Object.defineProperties(obj,{
            gender:{
                value:"male",
                enumerable:true
            },
            height:{
                value:175,
                enumerable:true
            }
        })
    3)Object.getOwnPropertyDescriptor(obj,"属性");
    用来检测某对象的某个属性的一些特性值
        console.log(Object.getOwnPropertyDescriptor(arr,"length"));//writable属性为true 所以数组的长度是可变的
8.Object对象常用的属性和方法
    Object 类型所具有的任何属性和方法也同样存在于其他对象中，任何对象继承于Object对象。
    Object(通常放在原型中)中常用的方法：
      constructor:      //保存用户创建当前对象的函数
      hasOwnProperty(propertyName); //检查给定的属性名是否是对象的自有属性，
      toString();     //返回对象的字符串表示
      valueOf();      //返回对象的字符串，数值，布尔值的表示。
      propertyIsEnumerable(propertyName); //检查给定的属性在当前对象实例中是否存在
      isPrototypeOf(object);    //检查传入的对象是否是原型
      toLocaleString();     //返回对象的字符串表示，该字符串与执行环境的地区对应



函数

1.声明
    1）函数声明（函数字面量）
      执行代码前会先提升函数声明并加载函数声明，
      函数声明不管在哪个地方都是有效的，只要在使用foo之前没有改变foo的值，访问foo时为function，若是改变了foo的值则使用foo则会变为改变后的值。
        function sayHello(){
            console.log("hello");
        }
    2）函数表达式 有函数提升，不能把函数调用写在函数声明之前
        // var sayHello=undefined;函数提升变成undefined，不能在给函数赋值前调用，否则会报错。
        var sayHello=function(){
            console.log("hello");
        }
    3）构造函数Function()

2.函数的调用
    sayHello(实参列表);
    sayHello.call(执行环境对象this，实参列表);
    sayHello.apply(执行环境对象，实参列表数组);

3.函数没有返回值(return)时返回undefined,

4.函数的内部属性arguments和this.特点是只能在函数内部运行
  (1)arguments类数组对象：函数调用时实际参入函数的实际参数列表，其中有重要的两个属性，length属性和callee属性
    通常可以用来计算传入的任意个数之间和差乘除之间的算术运算

        1）length:是指函数调用时实际参入函数的参数个数
        2）callee:保存的是这个函数 比如下面的函数中arguments.callee就是指add()，通常用来在阶乘中
                function add(){
                    console.log("asdah");
                }
  (2)this：指向的是函数赖以执行的对象
     直接调用函数是指向window
     对象调用方法是指向该对象

5.函数的属性和方法：
    1)length属性:指的是函数期望传入函数内部的参数，即形参个数，与函数内部arguments.length区分开
    2)call()方法：第一个参数是 this指向，第二个是参数列表
    3)apply()方法：第一个参数是 this指向，第二个是数组形式的参数列表

6.函数的运用
    函数可以作为参数使用
    函数可以作为函数的返回值

7.函数的高级特性
    构造器函数是一种特殊的对象，
    每一个函数对象对应一个原型对象（用来储存共享信息）
    在声明构造函数的同时会创建一个原型对象，可以用 构造函数.prototype指向这个原型对象，
    原型对象默认有一个constructor属性，保存的是这个构造函数
    用构造器函数创建的实例对象默认链接到函数的原型对象，
    原来是不能用实例对象访问原型对象的，后来可以使用__proto__属性访问原型对象



#值传递和引用传递
1.值传递：基本数据类型的传递，传递的是变量的值，在函数内部修改变量是不会改变外部的值
        var a="hello";
        function test(a){
            a="pig";
            console.log("hshs");
        }
        test(a);
        console.log(a);//"hello"
2.引用传递：引用数据类型的传递，传递的是对象的引用地址，在函数内部修改变量的会修改函数外部的值的。
        var a={
            name:"ls",
            age:12
        }
        function test(a){
            a.name="pig";
            console.log("haha");
        }
        test(a);



#undefined的取值情况
  1)变量声明但未赋值
    var a;//var a=undefined，显示声明未undefined类型
    console.log(a);//undefined
  2)函数没有返回值时
    function test(){
      console.log("hello");
    }
    var result=test();
    console.log(result);//undefined
  3)访问对象没有的属性
    var o={
      name:"ls",
      age:12
    }
    console.log(o.gender);//undefined



#函数提升和变量提升
  1.函数提升：
        1)函数声明的方式：在函数提升的同时加载函数，比函数表达式强大
            test();
            function test(){
              console.log("hello");
            }

            提升并加载后：
            function test(){
              console.log("hello");
            }
            test();
        2)函数表达式只会把函数提升到最上面，值为undefined.若函数调用写在声明之前会报错
            var test = function(){
              console.log("pig");
            }
            test();
            
            提升后：
            var test=undefined;//var test;
            test=function(){
              console.log("pig");
            }
            test();

 2.变量提升：用var 声明的变量会在预解析的时候提升
    b=12;
    function test(){
      console.log("hello");
    }
    console.log(a);
    var a="pig";
    函数提升和变量提升之后：
    function test(){
      console.log("hello");
    }
    var a;//var a=undefined;
    b=12;
    console.log(a);//undefined
    a="pig";
 
 3.预解析时，函数提升在变量提升之前


#day7

1. 对象创建(创建东西)
    var obj = new Object();
    obj.key = "value";

    var obj = {
        key : "value",
        key2: "value"
    }
2. 封装

    构造函数是创建对象的，构造函数首字母大写，普通函数是用来执行代码的

    1) 工厂函数模式
        封装一个普通函数，实现一个创建对象的函数
        只需调用函数传参就可创建一个对象
        function factory (id,name,age){
            return {
                id : id,
                name:name,
                age:age,
                sayName:function(){
                    console.log(this.name);
                }
            }
        }
        var p1 = factory(1,'terry',12);
        var p2 = factory(2,'larry',13);
        console.log(p1.sayName==p2.sayName);//false  内存地址不一样

        1. 数据类型无法细分 不能细分为自定义的一种类型
        2. 每创建一个对象，都要为这个对象初始化函数（函数在内存中重复创建）
           **如何实现函数复用：把这个函数提取出来，并把这个函数的地址赋值给函数中的函数属性值，但是这种方法不好，当函数比较多时，外部函数都写在外面不好管理。代码如下：
            function sayName(){
                    console.log(this.name);
            }

            function factory (id,name,age){
            return {
                id : id,
                name:name,
                age:age,
                sayName:sayName;
              }
            }

            var p1 = factory(1,'terry',12);
            var p2 = factory(2,'larry',13);
            console.log(p1.sayName==p2.sayName);//true

    2) 构造函数模式

        *构造函数在定义的时候会默认创建一个原型对象，这个原型是默认的，后期可以更改。
        //扩展了引用数据类型 函数，对象，数组，正则对象
        *自定义一种数据类型 ,可以将实例标识为一种特定的类型，而不是直接属于Object（东西）的类型
        function Person(id,name,age){
            this.id = id;
            this.name = name;
            this.age = age;
            this.sayName=function(){
               console.log(this.name);
            }
        }

        var stu = Student(1001,"ls",12);
        console.log(stu);//函数没有返回值 stu为空

        *构造函数一般是通过new关键字调用。
        var p1 = new Person(1,'larry',12);

        1.解决了类型细分问题(instanceof可以判定对象的所属自定义类型等)
            p1 instanceof Person
            p1 instanceof Object
        2.没有解决函数存储的问题(只要是用var声明一个对象时，每一个方法都会被重新在内存中创建一个，除非把函数放在原型中)
        每创建一个实例对象就会创建一个函数，不能实现函数复用
        
        3.构造函数的创建对象步骤：
            1) 创建一个新对象(new 关键字在内存中开辟一块空间 obj)
            2) 将构造函数的作用域赋给新对象（this指向这个新对象obj）
            3) 执行构造函数中的代码(通过构造函数给对象obj初始化)
            4) 返回新对象obj。(并且把它赋值给用 var 声明的变量)


    3) 原型模式与构造函数模式混用
       1.实例对象可以调用构造函数原型中的属性和方法

       2.实例对象中定义的变量是实例变量，而原型中定义的变量可以叫公共变量或者类变量。

       3.原则：将对象的自定义属性保存在对象中
        讲对象可以调用的方法保存到构造函数原型中（共享）
        function Person(id,name,age){
            this.id = id;
            this.name = name;
            this.age = age;
        }
        Person.prototype.sayName = function(){
            console.log(this.name);
        }

        4.属性搜索原则：每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。
            1) 首先从对象实例本身开始查找
            2) 如果不在对象实例中，则继续搜索指针指向的原型对象。


        5.删除实例属性：当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性(属性或者方法重写)。通过delete操作符可以完全删除实例属性。
            var o={
              toString:function(){
                return 1;
              }
            };
            o.toString();//调用的是O中重写的toString()方法，
        6.检测属性：
            1)in 操作符，检测属性是否在实例对象或者原型中
            2)hasOwnProperty()方法，检测属性是否是在实例对象中
        7.原生对象的原型：通过原生对象的原型，不仅可以取得所有默认方法的调用，而且可以定义新方法。可以向修改自定义对象的原型一样修改原生对象的原型，可以随时添加方法。
            String.prototype.startsWith = function(text){
              return this.indexOf(text) == 0;
            }
            var msg = "Hello world";
            alert(msg.startsWith("Hello")); //true


    ****8.当原型中的方法较多的时候，可以将这些方法保存到一个对象中，然后将这个对象赋值给构造函数的原型，改变原有的默认原型对象。
        这个新建的对象默认constructor指向Object,所以要显式改变它的指向
        Person.prototype = {
            constructor:Person,
            sayName:funciton(){

            },
            sayAge:function(){
                
            }
        }


3.回调函数：callback()，函数作为函数的参数
    好处：该怎么处理获取的数据由调用者本身决定

  //自己封装实现了一个forEach函数
    function hander(item,index){//函数声明，传入的是形参
      console.log(item,index);
    }

    var arr=[1,2,3,4,5];
    forEach(arr,hander);

        //封装 遍历数组的函数
    function forEach(arr,hander){
      /*
      for(var key in arr){
        var item = arr[key];
        hander.call(this,item,key);//实参
      }//key表示下标，此题中输出为字符串形式的下标值
      */
        for(var i=0;i<arr.length;i++){
            var item =arr[i];
            hander.call(this,item,i);//进行函数调用，传入的是实参
        }
    }


#day08

* 每次用构造函数创建一个对象时，都会调用一次构造函数并且给对象初始化。

一.es5面向对象：

#封装（封装创建对象的函数）

    工厂模式
    构造函数模式
    原型模式和构函结合

#继承：本质是子构造函数的原型指向父构造函数的实例对象。

  * 是对象会有原型，原型本身也是对象，所有原型又有原型，如此往复构成原型链，直到Object.prototype 到 null结束。

  * 定义：抽象，把各个底层相同的，相类似的东西抽象到顶层中，越具体的越在底层，越抽象的越在顶层，实现继承；若想要子构函中的方法不一样，则可以重写实现不一样的方法

  * 问题：需不需要继承？
    子函数的实例有时需要调用父函数原型中的方法，所以需要(继承)。
    比如 Object.prototype中的toString,valueOf等方法

  * 如何实现继承？
    1.默认继承：
        *所有构造函数定义的时候都会默认创建一个原型对象，（即默认原型）

        *所有函数的默认原型 都是Object的实例，所以可以调用Object.prototype的方法

          function Person(id,name){
          this.id = id;
          this.name = name;
          }
          Person.prototype.sayName = function(){
            console.log(this.name);
          }
          var p1 = new Person(1001,"ls");
          p1.sayName();
          
          p1.toString();//可以调用Object.prototype的toString方法
          console.log(Person.prototype instanceof Object);
        
        *代码逻辑图：默认继承.png

    2.自定义继承

    *****1)原型链继承：子构造函数的原型指向父构造函数创建的（实例）对象。（常用）
            
            function Animal(id,name){
              this.id = id;
              this.name = name;
            }
            Animal.prototype.sayName = function(){
              console.log(this.name);
            }

            function Dog(id,name,color){
              this.id = id;
              this.name = name;
              this.color = color;
            }
            Dog.prototype = new Animal();
            Dog.prototype.constructor = Dog;

            Dog.prototype.sayColor = function(){
              console.log(this.color);
            }
            var d2 = new Dog(1002,"一休","yellow");


        
          * Dog.prototype = new Animal();
            这个操作要在创建对象之前做，不然会使创建的对象不能继承原型中的方法
            
          *  Dog.prototype.constructor = Dog;
             要显示修改constructor,使它修改更彻底,如果不改变，那么new Animal这个实例本身没有constructor，会向上找它的原型，那么constructor默认就会是Animal构函。所以要显示修改它

          *如果在修改之前先创建了对象，这个对象将不会有原型中的方法，它指向默认原型。

          *函数构造图：1-自定义-原型链继承.png

        2)Animal.call(this,id,name);借用构造函数继承:解决子构造函数的属性继承父构造函数的属性，不必重复写代码
            function Animal(id,name){
              this.id = id;
              this.name =name;
            }
            Animal.prototype.sayName = function(){
              console.log(this.name);
            }
            function Dog(id,name,color){
              // Animal(id,name);进入Animal构函时，构函中的this指向window
              
              Animal.call(this,id,name);//用call调用函数时，Dog构函中的this指向赋值给了new这个新对象，所以call方法中的this就是这个保存的新对象。

              this.color = color;
            }
            Dog.prototype = new Animal();
            Dog.prototype.constructor = Dog;
            Dog.prototype.sayColor = function(){
              console.log(this.color);
            }
  

        3)组合函数:原型链继承和借用构造函数继承相结合使用
            * 在自构造函数中 Animal.call(this,id,name);   

            * 在创建对象之前 Dog.prototype = new Animal();

              function Animal(id,name){
                this.id = id;
                this.name =name;
              }
              Animal.prototype.sayName = function(){
                console.log(this.name);
              }
              function Dog(id,name,color){
                Animal.call(this,id,name);
                this.color = color;
              }
              Dog.prototype = new Animal();
              Dog.prototype.constructor = Dog;
              Dog.prototype.sayColor = function(){
                console.log(this.color);
              }

              function Bird(id,name,type){
                Animal.call(this,id,name);
                this.type = type;
              }
              Bird.prototype = new Animal();
              Bird.prototype.constructor = Bird;
              Bird.prototype.sayType = function(){
                console.log(this.type);
              }
              var b1 = new Bird(1001,"yixiu","八哥");
              var d1 = new Bird(1001,"bd","yellow");
              b1.sayName();
              b1.sayType();
              d1.sayName();
              d1.sayColor();

            * 把sayName共有的方法抽象出来放到父类Animal构函的原型中，而子类构函Dog和Bird的原型都有自己特有的sayColor和sayType方法。如此实现继承，并且借用构函来减少代码的冗余问题。

            *确定原型和实例的关系的方法：

              (1)原型.isPrototypeOf(instance)；只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型

                console.log(Bird.prototype.isPrototypeOf(b1));
                console.log(Animal.prototype.isPrototypeOf(b1));
                console.log(Object.prototype.isPrototypeOf(b1));

              (2)instanceof()，判断某个实例是不是某个构造函数的实例，只要是原型链中一条完整原型链里出现的构造函数，那么就是这些出现构造函数都算是这个实例的构函，结果为true。

                console.log(d1 instanceof Object);
                console.log(d1 instanceof Dog);
                console.log(d1 instanceof Animal);




二.API学习
//ECMAScript5 API  优化代码 练习数组的方法 

#数组 与对象的区别？ 查看微信收藏this ?构造函数中的方法实例不能调用？ 变量重名问题
1.数组的创建
    构造函数
        var arr=new Array();

        var arr=new Array(20);
        创建一个指定长度的数组，长度为20，数组中每一个元素都会被初始化为undefined

        var arr=new Array("te",12,true);
        创建一个数组，并使用实参进行初始化数组

    字面量
        var arr=[1,true,"hello"];//逗号分隔 最后一个不加 跟对象原则相同

2.数组方法
    数组序列化
        toString
        join    
    数组的增删
        push:向数组的尾部添加元素，数组长度加一，返回数组的长度
        pop:从数组的最后 开始删除元素，数组长度减一，返回这个被删除的值
        shift：向数组的头部添加元素，数组长度加一，返回数组的长度
        unshift：从数组的头部开始删除元素，数组长度减一，返回这个被删除的值

