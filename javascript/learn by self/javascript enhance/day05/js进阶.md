#js进阶

1.栈(先进后出)和堆.

2.执行上下文(当前代码的执行环境，它会形成一个作用域).
   
    * 分为三种：
   
       - 全局环境：js代码运行起来会首先进入到该环境。
       - 局部环境（函数环境）：当函数被调用执行时，会进入当前函数的执行代码
       - eval环境
    
    * js引擎会以堆栈的方式来处理它们（执行上下文），称为函数调用栈(call stack).用来管理这些函数的调用顺序.

    * 函数遇到return后会结束当前环境，直接将当前上下文跳出栈。

    * 特征：

            * 单线程，同步执行，只有栈顶上下文处于执行中，其他上下文等待。
            * 全局上下文只有唯一一个
            * 函数执行上下文个数不限
            * 每次某个函数调用，就有一个新的执行上下文为其创建

![](callStack.png =50*50)

3.一个执行上下文的生命周期
  
  * 创建阶段：执行上下文会分别创建变量对象，建立作用域链，确定this指针
  * 执行阶段：创建完毕后，会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。
 
![](executeEnvornment.png =50*50)

4.变量对象:js执行上下文生成后会创建一个叫做变量对象的特殊的对象，js的基本数据类型保存在变量对象中，引用数据类型把引用指针(哈希码)保存在变量对象中。

  * 创建变量对象经历三个过程：创建arguments  函数提升 变量提升
  * 未进入执行阶段之前，变量对象的属性不可访问，但进入执行阶段，变量对象变成活动对象，并且给变量赋值

![](CreateVo.png =50*50)

5. 作用域链
  
  * 作用域是一套规则，用来管理引擎如何在当前作用域以及子作用域中，根据变量名来进行变量查找.
  * 作用域链是这一套规则的具体实现，是由当前环境和上层环境的一系列变量对象组成.保证了当前执行环境对符合所有访问权限的变量和函数的有序访问。

![](scropechain.png =50*50)

6.闭包(浅识)

  * 简单的理解是定义在函数内部的函数
  * 闭包是能够读取其它函数内部变量的函数，而在js中，只有函数内部的子函数才能读取局部变量。所以可以理解为闭包是函数中的函数
  * 变量作用域：全局变量和局部变量
    
      * js中，函数内部可以直接读取全局变量
      * 在函数外部无法自然读取函数内部的局部变量
      * 那么如何解决从函数外部读取函数内部的局部变量
      ```
      解决方法：在函数内部再定义一个函数
      function f1(){
        var n=2093;
        function f2(){
          alert(n);
        }
        return f2;
      }
      var result = f1();
      result();

      ```

  * 闭包的用途：可以读取函数内部的变量；让这些变量的值始终在内存中。
  * 闭包的应用场景：
    
      * 延迟函数setTimeout
      
      ```
      for(var i = 1;i <=5; i++){
          setTimeout(function(){
            console.log(i);
          },1000*i);//5个setTimeout会依次在队列中，当for循环执行完成之后才会执行这个setTimeout的队列。所有结果是 6 6 6 6 6 6
      }

      页面中所有由setTimeout定义的操作，都将存放在同一个队列(先进先出)中依次执行。这些操作进入队列的顺序，由设定的延迟时间来确定。
      这个队列执行的时间，需要等到循环结束之后再执行。


      解决方法1：自执行函数
      for(var i = 1;i <= 5;i++){
        (function(i){
            setTimeout(function(){
              console.log(i);
            },i*5000)
        })(i);
      }//输出结果1 2 3 4 5 
      使用自执行函数提供闭包条件。
      
      解决方法2.可以在setTimeout的第一个参数处利用闭包
      for(var i = 1;i <= 5;i++){
        setTimeout((function(i){
          console.log(i);
        })(i),
        i*1000)
      }

      ```

      * 函数柯里化
      * 模块化


